"""
Abstract interface for privacy amplification.

This module defines the abstract base class for privacy amplification algorithms
used to compress the reconciled key and eliminate information leaked to
eavesdroppers.
"""

from abc import ABC, abstractmethod
from typing import Any
import numpy as np


class IPrivacyAmplifier(ABC):
    """
    Abstract interface for privacy amplification.
    
    Privacy amplification is the final step of quantum key distribution, where
    the reconciled key is compressed to eliminate any information that may have
    leaked to an eavesdropper during quantum transmission and error correction.
    
    Goal
    ----
    Compress key to account for Eve's partial information using 2-universal
    hashing based on the leftover hash lemma.
    
    Security
    --------
    Based on leftover hash lemma (2-universal hashing). If Eve's information
    about the key is bounded, hashing to a shorter length produces a key that
    is statistically close to uniform and independent of Eve's knowledge.
    
    Mathematical Foundation
    -----------------------
    The leftover hash lemma states that if:
    - H is a 2-universal hash function family
    - H_min(X|E) is the min-entropy of X given Eve's information E
    - m ≤ H_min(X|E) - 2log(1/ε)
    
    Then h(X) is ε-close to uniform and independent of E, where h is randomly
    chosen from H.
    
    Notes
    -----
    Toeplitz matrices are commonly used as they provide efficient 2-universal
    hashing with simple matrix-vector multiplication in GF(2).
    """
    
    @abstractmethod
    def generate_hash_seed(self, input_length: int, output_length: int) -> Any:
        """
        Generate random seed for hash function.
        
        The seed defines a specific hash function from the 2-universal family.
        It must be chosen uniformly at random and shared between Alice and Bob.
        
        Parameters
        ----------
        input_length : int
            Length of input key (sifted & reconciled).
        output_length : int
            Desired final key length.
        
        Returns
        -------
        seed : Any
            Seed defining the hash function (e.g., Toeplitz matrix seed).
        
        Notes
        -----
        For Toeplitz hashing: seed is a random bitstring of length (m + n - 1),
        where m is output_length and n is input_length. This seed defines a
        Toeplitz matrix that can be efficiently applied via convolution.
        
        The seed can be generated by either party and transmitted classically,
        or derived from a shared random source.
        """
        pass
    
    @abstractmethod
    def compress(self, key: np.ndarray, seed: Any) -> np.ndarray:
        """
        Apply privacy amplification hash function.
        
        This method applies the 2-universal hash function (defined by the seed)
        to compress the reconciled key to the secure final length.
        
        Parameters
        ----------
        key : np.ndarray
            Reconciled key of length n.
        seed : Any
            Hash function seed.
        
        Returns
        -------
        final_key : np.ndarray
            Compressed key of length m < n.
        
        Mathematical Definition
        -----------------------
        For Toeplitz matrix T ∈ GF(2)^{m×n}:
            final_key = T · key (mod 2)
        
        The Toeplitz structure allows efficient computation using FFT-based
        convolution, reducing complexity from O(mn) to O(n log n).
        
        Security
        --------
        By leftover hash lemma, if H_min(key|E) ≥ m + 2log(1/ε), then final_key
        is ε-close to uniform and independent of E (Eve's information).
        """
        pass
    
    @abstractmethod
    def compute_final_length(self, sifted_length: int, qber: float,
                            leakage: float, epsilon: float) -> int:
        """
        Calculate secure final key length.
        
        This method computes the maximum secure output length based on the
        sifted key length, measured QBER, reconciliation leakage, and target
        security parameter.
        
        Parameters
        ----------
        sifted_length : int
            Length of reconciled key.
        qber : float
            Measured QBER.
        leakage : float
            Information leaked during reconciliation (bits).
        epsilon : float
            Target security parameter.
        
        Returns
        -------
        final_length : int
            Maximum secure output length.
        
        Mathematical Definition
        -----------------------
        From leftover hash lemma:
            m ≤ n · [1 - h(qber)] - leakage - 2log₂(1/ε)
        
        Where:
        - n is sifted_length
        - h(x) = -x·log₂(x) - (1-x)·log₂(1-x) is binary entropy
        - The term n · [1 - h(qber)] is the extractable entropy
        - leakage accounts for information revealed during reconciliation
        - 2log₂(1/ε) is the security parameter term
        
        Notes
        -----
        This formula assumes collective attacks. For coherent attacks, additional
        security margins may be needed. The baseline implementation uses this
        standard formula with a conservative safety margin.
        """
        pass
