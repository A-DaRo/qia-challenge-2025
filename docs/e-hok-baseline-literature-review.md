# Baseline E-HOK Protocol: Step-by-Step Analysis

**Phase I - Quantum Key Generation:** Alice and Bob use entangled qubit pairs (e.g. Bell states) to produce correlated raw bits. In practice, a central source (Alice) can create polarization-entangled photon pairs (e.g. the $|\Phi^+\rangle$ Bell state) via SPDC 1. Alice and Bob each choose a random basis (Z or X) for each qubit and immediately measure. When they happen to use the same basis, their outcomes are perfectly (anti-)correlated 2. They record their bit outcomes and basis choices locally, forming raw strings $s,a$ (Alice) and $\bar s,\bar a$ (Bob).

**Phase II - Commitment (Trust Anchor):** Before Alice learns Bob's bases, Bob must commit to his measurement results so he cannot alter them later. Concretely, Bob concatenates his outcome/basis pairs and sends Alice a cryptographic commitment (e.g. a SHA-256 hash) of this string 3 4. Alice's program blocks until this single hash $H=\mathrm{Hash}(\bar s\bar a)$ arrives. This classical hash-based commitment (as in Halevi-Micali-type schemes) is computationally binding 3, meaning Bob cannot change $\bar s,\bar a$ later without finding a hash collision. This matches Lemus et al.'s "hash-function commitment" approach 3 4.

**Phase III - Sifting & Sampling (Verification):** Alice now announces her basis string $a$. Bob identifies the matching-index set $I_0=\{i:a_i=\bar a_i\}$ (sifted key positions) and $I_1$ (mismatches). They then perform a statistical test: Alice picks a random subset $T\subset I_0$ for error estimation. Bob opens his commitments for all $i\in T$, revealing $\bar s_i$ and the randomness used (hash salt). Alice verifies these against $H$ to ensure honesty. She then computes the quantum bit error rate (QBER) on $T$. If QBER exceeds the abort threshold (typically $\sim 11\%$), they abort 5 6. Otherwise, they discard $T$ and all mismatched bits $I_1$. This is exactly the usual QKD sifting: mismatched-basis results are publicly discarded and only matching-basis bits remain 2.

**Phase IV - Information Reconciliation:** The remaining sifted bits (in $I_0\setminus T$) may still contain errors. Alice and Bob now perform error correction. For example, Alice loads a parity-check (LDPC) matrix $M$ and computes a syndrome $S=M\cdot s_{I_0}$; she sends $S$ to Bob. Bob uses an LDPC belief-propagation decoder to correct his $\bar s_{I_0}$ to match Alice's. LDPC codes are standard in QKD for reconciliation because they can correct errors in linear time with one-way communication 7 8. (Indeed, Lemus et al. implemented IR with an LDPC code 7.) After decoding, Alice and Bob exchange a short hash of the corrected key to confirm it matches.

**Phase V - Privacy Amplification:** Alice and Bob now distill a secure key by compressing their (error-corrected) sifted key to account for leaked information. A common method is to agree on a random universal hash (e.g. a Toeplitz matrix) and both apply it to their bit strings. Alice generates a random seed for an $m\times n$ Toeplitz matrix and sends it to Bob; both compute $K_{\rm final}=M_{\rm Toeplitz}\,s_{I_0}$. Toeplitz hashing is a 2-universal hash family widely used in QKD PA 7 8. By the leftover-hash lemma, this yields a final $\epsilon$-secure key, shorter by roughly the estimated leakage (from QBER and syndromes). In the **ObliviousKey** data structure, Alice's `knowledge_mask` is all zeros (she knows every output bit), while Bob's mask has 1's at positions he never knew (the discarded $I_1$ bits) 9. Thus Bob outputs $(K_{\rm final},x)$ where $x$ marks which bits of the original string he was ignorant of, as defined in the literature 9.

**Merkle-Tree Commitment Optimization:** To improve efficiency, Bob's initial commitment can use a **Merkle tree** instead of sending $N$ separate hashes. Bob treats each measurement pair $(\bar s_i,\bar a_i)$ as a leaf, builds a binary Merkle tree, and sends only the root hash $R$ to Alice 10. When Alice challenges subset $T$, Bob reveals for each $i\in T$ the leaf value $(\bar s_i,\bar a_i)$ plus the sibling hashes along its path. Alice checks each leaf against $R$ via these proofs. This achieves a constant-size commitment (the root) and logarithmic proofs: each opened bit requires $O(\log N)$ sibling hashes 10 11. In total, communication is $O(1)$ for commit and $O(|T|\log N)$ for openings, instead of $O(N)$. This classic Merkle-tree technique thus drastically reduces overhead while preserving security 10 11.

**Implementation note:** we should integrate Merkle-based commit in the baseline (via the `ICommitmentScheme` interface) and in future extensions. It fits seamlessly into the plan (just swapping the hash function with a Merkle-hash class) and yields large throughput gains.

**Summary:** Each step of the baseline E-HOK workflow is supported by established quantum and cryptographic techniques. Entanglement-based key generation and random-basis measurement is standard in QKD 1 2; hash-based commitment and sampling for honesty tests appears in prior quantum OT protocols 3 5; LDPC reconciliation and Toeplitz privacy amplification are well-known efficient methods 7 8; and the oblivious-key object (Alice's full key vs Bob's partially-known key) matches the formal definition 9. The Merkle-tree optimization is a natural classical refinement (recently popular in blockchain and data integrity) that dramatically reduces communication 10 11. Altogether, these choices form a modular baseline consistent with the literature, ready for later swapping to advanced R&D components.

**Sources:** We draw on the quantum-OT literature and QKD post-processing texts for justification. In particular, Lemus et al. describe a similar entanglement-based OT protocol with hash commitments 3 5, and their implementation used LDPC and Toeplitz hashing for IR/PA 7 8. Merkle commitments are classical primitives known to allow succinct commits with logarithmic reveals 10 11. Detailed discussion of each phase can be found in these and related works.

1 7 8 `./literature/Performance of Practical Quantum Oblivious Key Distribution.md` (https://arxiv.org/abs/2501.03973)

2 `./literature/The Ekert Protocol.md` (https://www.ux1.eiu.edu/~nilic/Nina's-article.pdf)

3 4 5 6 9 [1909.11701] `./literature/Generation and Distribution of Quantum Oblivious Keys for Secure Multiparty Computation.md` (https://arxiv.org/abs/1909.11701)

10 `./literature/Quantum Merkle Trees.md` (https://quantum-journal.org/papers/q-2024-06-18-1380/pdf/)

11 Merkle Tree (https://link.springer.com/chapter/10.1007/0-387-34805-0_21)